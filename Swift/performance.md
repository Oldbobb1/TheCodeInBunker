# 8 советов по производительности Swift, которые я узнал после многих лет программирования

### 1. Отдавайте предпочтение структурам, а не классам
Swift поощряет использование структур вместо классов, когда это возможно. Структуры размещаются в стеке, что может привести к повышению производительности за счет более быстрого доступа и снижения накладных расходов памяти.
Вместо:
class User {
    var name: String
    var age: Int
}

init(name: String, age: Int) {
        self.name = name
        self.age = age
    }
Используйте:
struct User {
    var name: String
    var age: Int
}
Почему?
Структуры обеспечивают семантику копирования, что может предотвратить непредвиденные побочные эффекты и сделать ваш код более безопасным. Кроме того, компилятор может оптимизировать структуры более эффективно, чем классы, что приводит к росту производительности.

2. Используйте ленивые свойства для ресурсоемких инициализаций
Ленивые свойстваинициализируются только при первом обращении к ним, что делает их эффективным способом экономии ресурсов. Такой подход особенно полезен для свойств, инициализация которых требует больших вычислительных затрат и может потребоваться не сразу.
Пример:
class DataManager {
    lazy var expensiveData: [String] = {
        // Simulating a heavy data-loading process
        var data = [String]()
        for i in 0..<10000 {
            data.append("Item \(i)")
        }
        return data
    }()
}
Почему?
Откладывание инициализации дорогих данных до тех пор, пока они не понадобятся, сокращает время начальной загрузки приложения, что приводит к более быстрому и плавному взаимодействию с пользователем.

3. Оптимизация массивов путем предварительного распределения объема
При работе с массивами, которые динамически растут, предварительное распределение их объема может значительно повысить производительность за счет снижения накладных расходов на многократное перераспределение памяти.
Вместо этого:
var numbers = [Int]()
for i in 0..<1000 {
    numbers.append(i)
}
Используйте такой код:
var numbers = [Int]()
numbers.reserveCapacity(1000)
for i in 0..<1000 {
    numbers.append(i)
}
Почему?
Предварительное распределение объема позволяет массиву заранее выделить достаточно памяти для хранения предполагаемого количества элементов. Это минимизирует операции изменения размера и копирования, которые могут быть дорогостоящими, особенно в циклах, критичных к производительности.

4. Используйте параллелизм Swift с помощью Async/Await
Синтаксис async/await в Swift революционизируетпараллельное программирование, позволяя задачам выполняться асинхронно, не блокируя основной поток. Этот современный подход упрощает код и значительно повышает производительность при выполнении операций ввода-вывода.
Пример:
func fetchData() async throws -> Data {
    let url = URL(string: "https://api.example.com/data")!
    let (data, _) = try await URLSession.shared.data(from: url)
    return data
}

func loadData() {
    Task {
        do {
            let data = try await fetchData()
            // Process data
        } catch {
            print("Error fetching data: \(error)")
        }
    }
}
Почему?
Использование async/await гарантирует, что ваше приложение сможет обрабатывать сетевые запросы или другие трудоемкие задачи без зависания пользовательского интерфейса, что приведет к более плавному взаимодействию с пользователем.

5. Сведите к минимуму использование Optional в коде, критичном к производительности
Optional неоценимы для безопасной обработки отсутствия значений, но их чрезмерное использование в коде может привести к ненужным накладным расходам.
Вместо этого:
func calculate(_ value: Int?) -> Int {
    guard let unwrapped = value else { return 0 }
    return unwrapped * 2
}
Используйте:
func calculate(_ value: Int) -> Int {
    return value * 2
}
Почему?
Избегая ненужных Optional, вы избавляетесь от затрат на разворачивание и проверку на nil, что приводит к ускорению выполнения.	Используйте Optional только в тех случаях, когда отсутствие значения является значимым и неизбежным.

6. Используйте типы данных для обеспечения потокобезопасности
Типы данных (Value Types) Swift, такие как структуры и перечисления, по своей сути являются потокобезопасными благодаря copy-on-assignment поведению. Это делает их идеальными для параллельных сред.
Пример:
struct Point {
    var x: Double
    var y: Double
}

func updatePoint(_ point: Point) -> Point {
    var newPoint = point
    newPoint.x += 10
    newPoint.y += 20
    return newPoint
}
Почему?
Типы значений предотвращают гонки данных, гарантируя, что каждый поток работает со своей копией данных, что устраняет необходимость в сложных механизмах синхронизации.

7. Оптимизируйте операции со строками с помощью String API
Эффективная работа со строками — это ключ к тому, чтобы избежать узких мест в производительности вашего приложения. Swift String API предоставляет оптимизированные методы для различных задач.
Вместо:
var combined = ""
for word in words {
    combined += word + " "
}
Используйте:
let combined = words.joined(separator: " ")
Почему?
Использование joined(separator:)минимизирует выделение ресурсов на промежуточные строки и повышает производительность по сравнению с ручной конкатенацией в циклах.
Совет
Используйте встроенные методы Swift для упрощения и оптимизации работы со строками.

8. Профилирование и бенчмаркинг с помощью Xcode Instruments
Ни один путь оптимизации не может быть полным без анализа данных. Xcode Instrumentsпредоставляет мощные инструменты для выявления и устранения узких мест в производительности.
Зачем?
Профилирование позволяет сосредоточиться на реальных проблемах производительности, а не на догадках, что приводит к эффективным и действенным оптимизациям.

